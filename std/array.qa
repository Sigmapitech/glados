# Quant Standard Library - Array Module
# Provides utilities for working with arrays

# Get array length
fn len(arr: [int]) -> int {
    # Built-in implementation
}

# Push element to end of array
fn push(arr: [int], item: int) -> void {
    # Built-in implementation
    # Modifies array in place
}

# Pop element from end of array
fn pop(arr: [int]) -> int {
    # Built-in implementation
    # Returns last element and removes it
}

# Reverse array (returns new array)
fn reverse(arr: [int]) -> [int] {
    result: [int];
    i: int = len(arr) - 1;

    while (i >= 0) {
        push(result, arr[i]);
        i = i - 1;
    };

    return result;
}

# Sort array in ascending order (returns new array)
fn sort(arr: [int]) -> [int] {
    # Built-in implementation
    # Uses quicksort or similar algorithm
}

# Find element in array (returns index or -1)
fn index_of(arr: [int], target: int) -> int {
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        if (arr[i] == target) {
            return i;
        };
        i = i + 1;
    };

    return -1;
}

# Check if array contains element
fn contains(arr: [int], target: int) -> bool {
    return index_of(arr, target) != -1;
}

# Extract slice from array (start inclusive, end exclusive)
fn slice(arr: [int], start: int, end: int) -> [int] {
    result: [int];
    i: int = start;

    while (i < end) {
        push(result, arr[i]);
        i = i + 1;
    };

    return result;
}

# Sum all elements in array
fn sum(arr: [int]) -> int {
    total: int = 0;
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        total = total + arr[i];
        i = i + 1;
    };

    return total;
}

# Get minimum value in array
fn min(arr: [int]) -> int {
    if (len(arr) == 0) {
        return 0;  # Or error
    };

    min_val: int = arr[0];
    i: int = 1;
    length: int = len(arr);

    while (i < length) {
        if (arr[i] < min_val) {
            min_val = arr[i];
        };
        i = i + 1;
    };

    return min_val;
}

# Get maximum value in array
fn max(arr: [int]) -> int {
    if (len(arr) == 0) {
        return 0;  # Or error
    };

    max_val: int = arr[0];
    i: int = 1;
    length: int = len(arr);

    while (i < length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        };
        i = i + 1;
    };

    return max_val;
}

# Fill array with value
fn fill(arr: [int], value: int) -> void {
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        arr[i] = value;
        i = i + 1;
    };


# Copy array (shallow copy)
fn copy(arr: [int]) -> [int] {
    result: [int];
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        push(result, arr[i]);
        i = i + 1;
    };

    return result;
}

# Check if all elements satisfy predicate
# Note: This is a simplified version without higher-order functions
fn all_positive(arr: [int]) -> bool {
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        if (arr[i] <= 0) {
            return False;
        };
        i = i + 1;
    };

    return True;
}

# Check if any element satisfies predicate
fn any_positive(arr: [int]) -> bool {
    i: int = 0;
    length: int = len(arr);

    while (i < length) {
        if (arr[i] > 0) {
            return True;
        };
        i = i + 1;
    };

    return False;
}
