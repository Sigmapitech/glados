# Quant Standard Library - Math Module
# Provides mathematical functions and constants

# Absolute value for integers
fn abs_int(x: int) -> int {
    if (x < 0) {
        return -x;
    };
    return x;
}

# Absolute value for floats
fn abs_float(x: float) -> float {
    if (x < 0.0) {
        return -x;
    };
    return x;
}

# Minimum of two integers
fn min_int(a: int, b: int) -> int {
    if (a < b) {
        return a;
    };
    return b;
}

# Maximum of two integers
fn max_int(a: int, b: int) -> int {
    if (a > b) {
        return a;
    };
    return b;
}

# Minimum of two floats
fn min_float(a: float, b: float) -> float {
    if (a < b) {
        return a;
    };
    return b;
}

# Maximum of two floats
fn max_float(a: float, b: float) -> float {
    if (a > b) {
        return a;
    };
    return b;
}

# Power function - raise base to exponent
fn exp(x: float) -> float {
    term: float = 1.0;
    sum: float = 1.0;
    n: int = 1;

    while (n < 30) {
        term = term * x / n;
        sum = sum + term;
        n = n + 1;
    };
    return sum;
}


fn log(x: float) -> float {
    if (x <= 0.0) {
        sys.exit(136);
    };

    y: float = 0.0;
    i: int = 0;

    while (i < 25) {
        ey: float = exp(y);
        y = y - (ey - x) / ey;
        i = i + 1;
    };
    return y;
}


fn pow(base: float, exp: float) -> float {
    if (base <= 0.0) {
        sys.exit(136);
    };
    return exp(exp * log(base));
}

# Square root
fn sqrt(x: float) -> float {
    if (x < 0.0) {
        sys.exit(136);
    };
    if (x == 0.0) {
        return 0.0;
    };

    guess: float = x;
    i: int = 0;

    while (i < 20) {
        guess = 0.5 * (guess + x / guess);
        i = i + 1;
    };
    return guess;
}

# Floor - round down to nearest integer
fn floor(x: float) -> int {
    int_part: int = int(x);
    if (float(int_part) > x) {
        return int_part - 1;
    };
    return int_part;
}

# Ceiling - round up to nearest integer
fn ceil(x: float) -> int {
    int_part: int = int(x);
    if (float(int_part) < x) {
        return int_part + 1;
    };
    return int_part;
}

# Round to nearest integer
fn round(x: float) -> int {
    int_part: int = int(x);
    frac_part: float = x - float(int_part);
    if (frac_part >= 0.5) {
        return int_part + 1;
    };
    if (frac_part <= -0.5) {
        return int_part - 1;
    };
    return int_part;
}

# Clamp value between min and max
fn clamp_int(value: int, min_val: int, max_val: int) -> int {
    if (value < min_val) {
        return min_val;
    };
    if (value > max_val) {
        return max_val;
    };
    return value;
}

# Clamp float value between min and max
fn clamp_float(value: float, min_val: float, max_val: float) -> float {
    if (value < min_val) {
        return min_val;
    };
    if (value > max_val) {
        return max_val;
    };
    return value;
}

# Sign function - returns -1, 0, or 1
fn sign_int(x: int) -> int {
    if (x < 0) {
        return -1;
    };
    if (x > 0) {
        return 1;
    };
    return 0;
}

# Calculate factorial (recursive)
fn factorial(n: int) -> int {
    if (n <= 1) {
        return 1;
    };
    return n * factorial(n - 1);
}

# Calculate greatest common divisor (GCD)
fn gcd(a: int, b: int) -> int {
    a = abs_int(a);
    b = abs_int(b);

    while (b != 0) {
        temp: int = b;
        b = a % b;
        a = temp;
    };
    return a;
}

# Calculate least common multiple (LCM)
fn lcm(a: int, b: int) -> int {
    if (a == 0 || b == 0) {
        return 0;
    };
    return abs_int(a * b) / gcd(a, b);
}
