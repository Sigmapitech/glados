# Quant Standard Library - Math Module
# Provides mathematical functions and constants

# Absolute value for integers
fn abs(x: int) -> int {
    if (x < 0) {
        return -x;
    };
    return x;
}

# Absolute value for floats
fn fabs(x: float) -> float {
    if (x < 0.0) {
        return -x;
    };
    return x;
}

# Minimum of two integers
fn min(a: int, b: int) -> int {
    if (a < b) {
        return a;
    };
    return b;
}

# Maximum of two integers
fn max(a: int, b: int) -> int {
    if (a > b) {
        return a;
    };
    return b;
}

# Minimum of two floats
fn fmin(a: float, b: float) -> float {
    if (a < b) {
        return a;
    };
    return b;
}

# Maximum of two floats
fn fmax(a: float, b: float) -> float {
    if (a > b) {
        return a;
    };
    return b;
}

# Power function - raise base to exponent
fn exp(x: float) -> float {
    term: float = 1.0;
    sum: float = 1.0;
    n: int = 1;

    while (n < 30) {
        term = term * x / n;
        sum = sum + term;
        n = n + 1;
    };
    return sum;
}


fn log(x: float) -> float {
    if (x <= 0.0) {
        sys.exit(136);
    };

    y: float = 0.0;
    i: int = 0;

    while (i < 25) {
        ey: float = exp(y);
        y = y - (ey - x) / ey;
        i = i + 1;
    };
    return y;
}


fn pow(base: float, exp: float) -> float {
    if (base <= 0.0) {
        sys.exit(136);
    };
    return exp(exp * log(base));
}

# Square root
fn sqrt(x: float) -> float {
    if (x < 0.0) {
        sys.exit(136);
    };
    if (x == 0.0) {
        return 0.0;
    };

    guess: float = x;
    i: int = 0;

    while (i < 20) {
        guess = 0.5 * (guess + x / guess);
        i = i + 1;
    };
    return guess;
}

# Floor - round down to nearest integer
fn floor(x: float) -> int {
    int_part: int = int(x);
    if (float(int_part) > x) {
        return int_part - 1;
    };
    return int_part;
}

# Ceiling - round up to nearest integer
fn ceil(x: float) -> int {
    int_part: int = int(x);
    if (float(int_part) < x) {
        return int_part + 1;
    };
    return int_part;
}

# Round to nearest integer
fn round(x: float) -> int {
    int_part: int = int(x);
    frac_part: float = x - float(int_part);
    if (frac_part >= 0.5) {
        return int_part + 1;
    };
    if (frac_part <= -0.5) {
        return int_part - 1;
    };
    return int_part;
}

# Clamp value between min and max
fn clamp(value: int, min_val: int, max_val: int) -> int {
    if (value < min_val) {
        return min_val;
    };
    if (value > max_val) {
        return max_val;
    };
    return value;
}

# Clamp float value between min and max
fn fclamp(value: float, min_val: float, max_val: float) -> float {
    if (value < min_val) {
        return min_val;
    };
    if (value > max_val) {
        return max_val;
    };
    return value;
}

# Calculate factorial (recursive)
fn factorial(n: int) -> int {
    if (n <= 1) {
        return 1;
    };
    return n * factorial(n - 1);
}

# Calculate greatest common divisor (GCD)
fn gcd(a: int, b: int) -> int {
    a = abs_int(a);
    b = abs_int(b);

    while (b != 0) {
        temp: int = b;
        b = a % b;
        a = temp;
    };
    return a;
}

# Calculate least common multiple (LCM)
fn lcm(a: int, b: int) -> int {
    if (a == 0 || b == 0) {
        return 0;
    };
    return abs_int(a * b) / gcd(a, b);
}

// Trigonometric functions
fn wrap_angle(x: float) -> float {
    TAU: const float = 6.28318530717958647692;  # 2 * PI
    # Reduce x to [-PI, PI]
    t: float = x - (int(x / TAU) * TAU);
    if (t > PI) {
        t -= TAU;
    };
    if (t < -PI) {
        t = t + TAU;
    };
    return t;
}

fn sin(x: float) -> float {
    x = wrap_angle(x);

    term: float = x;       # first term x^1 / 1!
    sum: float = x;
    x2: float = x * x;
    sign: float = -1.0;

    i: int = 1;
    while (i <= 5) {       # 5 more terms
        term = (term * x2) / ((2*i) * (2*i+1));
        sum = sum + (sign * term);
        sign = -sign;
        i ++;
    };
    return sum;
}

fn cos(x: float) -> float {
    x = wrap_angle(x);

    term: float = 1.0;     # first term x^0 / 0! = 1
    sum: float = 1.0;
    x2: float = x * x;
    sign: float = -1.0;

    i: int = 1;
    while (i <= 5) {       # 5 more terms
        term = (term * x2) / ((2*i-1) * (2*i));
        sum = sum + (sign * term);
        sign = -sign;
        i ++;
    };
    return sum;
}
